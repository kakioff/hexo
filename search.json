[{"title":"锚点定位scrollIntoView平滑过渡","url":"/posts/e0f7c0ec/","content":"\n一般网站使用的锚点定位都是使用的a标签，但是实际使用的时候会很生硬\n\n使用scrollIntoView就可以达到很好的效果,切换时有平滑过渡\n\n使用\n\ndocument.getElementById(\"domId\").scrollIntoView({    behavior: \"smooth\" // 平滑过渡 })\n\n可选API\n\n\n\n\napi\n必须\n描述\n\n\n\n\nalignToTop\nfalse\ntrue: (默认)元素的顶端将和其所在滚动区的可视区域的顶端对齐。false: 元素的底端将和其所在滚动区的可视区域的底端对齐。\n\n\nscrollIntoViewOptions\nfalse\nbehavior: 定义动画过渡效果,auto(默认)/smoothblock: 定义垂直方向的对齐,start(默认)/center/endnearest inline: 定义水平方向的对齐,start/center/end/nearest(默认)\n\n\n\n\n官网示例\n\nvar element = document.getElementById(\"box\");element.scrollIntoView();element.scrollIntoView(false);element.scrollIntoView({block: \"end\"});element.scrollIntoView({behavior: \"smooth\", block: \"end\", inline: \"nearest\"});","categories":["javascript"],"tags":["平滑过渡","scrollIntoView"]},{"title":"安装VMware,主机键盘不能用解决方法","url":"/posts/5d59a84c/","content":"\n不是第一次出现这个问题了，记录一下\n\n右键电脑-属性-硬件-设备管理器，键盘那一项显示黄色叹号，属性显示为 由于其配置信息（注册表中的）不完整或已损坏，Windows 无法启动这个硬件设备\nVMware安装以后会在C盘program files文件夹下生成VMware文件夹，卸载以后这个文件夹并不会消失掉,删掉这个文件夹系统会提示有文件受保护或正在运行，无法删除，强制或者修复VMware以后，再次开机键盘不能用了，但是外接usb键盘也不能用\n解决方案\n\nwin10右键状态栏可开启 触摸键盘按钮 ，可正常打字\n\n\n右键开始，点击运行regedit.exe，进入注册表编辑器 到左边的项目栏里定位到 定位到 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E96B-E325-11CE-BFC1-08002BE10318} 这一项\n注册表里面UpperFilters这一项，右键它修改，把内容改成kbdclass，点确定，没有UpperFilters这一项的话在注册表空白处右键添加字符串名字UpperFilters项，内容写成kbdclass\n然后再右键我的 电脑→属性→硬件→设备管理器→键盘 全部右键卸载\n然后再空白处右键点扫描检测硬件改动，等两秒钟，你会发现键盘可以用了，笔记本的话触摸板现在还不能用，现在重启电脑就可以了\n\n","tags":["VMware"]},{"title":"Vue切换路由模式，去掉链接后面的#","url":"/posts/c3dc9889/","content":"\n最近开发一个Vue项目，但是链接后面一直显示一个#，显得很不美观 只需要将vue-router的模式换成history就行了\n\n//hash就是有#的，也是默认的const router = new VueRouter({\tmode:'history',\troutes:[……],\t……})\n\n但是我的是vue3，这个方法没用，也没找到const router = new VueRouter 就可以用下面的方式\n\nimport {\tcreateRouter,\t//createWebHashHistory, // hash模式\tcreateWebHistory//history模式} from 'vue-router';const router = createRouter({  // history: createWebHashHistory(), // hash模式  history: createWebHistory(process.env.BASE_URL),//history模式  routes});\n\n现在链接显示就正常了，nice\n\n","categories":["vue"],"tags":["vue","history","vue3"]},{"title":"踩坑layui的tree组件-树形组件","url":"/posts/85af1ad9/","content":"layui的树形组件， data数组配置title和children之后使用tree.getChecked('tree.id')之后返回的是空数据\n这里在data中必须加一个id才可以\ntree.render({      elem: '#test1',  //绑定元素      data: [{        title: '江西',        id: 1,        children: [{          title: '南昌',          id: 2,          children: [{            title: '高新区',            id: 3,            //…… //以此类推，可无限层级          }]        }]      },{        title: '陕西',        id: 4,        children: [{          title: '西安',          id: 4,        }]      }]    });","tags":["layui","tree组件"]},{"title":"vue引入外部cdn报错 ‘XXX is not defined’","url":"/posts/747dba99/","content":"\n我在vue网站中使用了vaptcha的验证码，在index.html中引入了CDN后使用的时候出现了vaptcha is not defined试了很多别的方法引入都没用\n\n如何解决\n\n\n先正常引入js文件，index.html的script标签或者什么的。\n\n\n在webpack.base.conf.js中进行配置\nexternals: {\tvaptcha: 'vaptcha'}\n\n\n但是vue-cli3要在vue.config.js中配置，要是没有就新建一个文件\n\n\n &nbsp; configureWebpack: {    externals: {  \t\t'vaptcha: 'vaptcha' \t}}\n使用的时候直接在vue文件中引入就好了\n​```javascript\nimport vaptcha from “vaptcha”\n\n","categories":["vue"],"tags":["vue","cdn"]},{"title":"利用 vue3 给 element-plus 的 el-dialog 增加拖拽功能","url":"/posts/69fe2e47/","content":"前言\n代码来自使用 vue3 的自定义指令给 element-plus 的 el-dialog 增加拖拽功能，用的时候发现一些问题，我进行了二次修改。\n变化\n\n限制边缘\n全屏效果\n限制在弹窗的 header 拖动\n增加用户体验🤣\n\n效果\n\n使用\n\n新建一个 js 文件，内容为如下代码\n在 main.js 中引入并 use // ......import dialogDrag from './assets/js/dialogDrag.js'var app = createApp(App)app.use(dialogDrag)// ......\n\n使用的时候 el-dialog 标签用一个 div 包起来，div 加上 v-dialogdrag &lt;div v-dialogdrag&gt;\t&lt;el-dialog v-model=\"show\" :title=\"title\"&gt;\t\t内容\t&lt;/el-dialog&gt;&lt;/div&gt;\n\n\n代码\nconst bus = require(\"vue3-eventbus\")const dialogDrag = (app) =&gt; {\tapp.directive('dialogdrag', {\t\t// 渲染完毕\t\tmounted(el) {\t\t\t// 可视窗口的宽度\t\t\tconst clientWidth = document.documentElement.clientWidth\t\t\t// 可视窗口的高度\t\t\tconst clientHeight = document.documentElement.clientHeight\t\t\t// 记录坐标\t\t\tlet domset = {\t\t\t\tx: clientWidth / 4, // 默认width 50%\t\t\t\ty: clientHeight * 15 / 100 // 根据 15vh 计算\t\t\t}\t\t\t// 弹窗的容器\t\t\tconst domDrag = el.firstElementChild.firstElementChild\t\t\t// 超出部分隐藏，不显示滚动条\t\t\tel.firstElementChild.style.overflow = \"hidden\"\t\t\t// 重新设置上、左距离\t\t\tdomDrag.style.marginTop = domset.y + 'px'\t\t\tdomDrag.style.marginLeft = domset.x + 'px'\t\t\t// 记录拖拽开始的光标坐标，0 表示没有拖拽\t\t\tlet start = {\t\t\t\tx: 0,\t\t\t\ty: 0\t\t\t}\t\t\t// 移动中记录偏移量\t\t\tlet move = {\t\t\t\tx: 0,\t\t\t\ty: 0\t\t\t}\t\t\t// 限制拖动弹窗的 header 才可以移动弹窗\t\t\tconst dialogHeader = el.getElementsByClassName('el-dialog__header')[0]\t\t\t\t\t\t// 添加右上角全屏显示按钮， i 标签是阿里图标库里面的\t\t\tlet div = document.createElement('div')\t\t\tdiv.style.fontSize='.8rem'\t\t\tdiv.style.position='absolute'\t\t\tdiv.style.right='45px'\t\t\tdiv.style.top='20px'\t\t\tlet full_button = document.createElement('span')\t\t\tfull_button.style.cursor='pointer'\t\t\tfull_button.innerHTML='&lt;i class=\"iconfont icon-full\"&gt;&lt;/i&gt;'\t\t\tfull_button.addEventListener('click', full_dia) // 单击全屏\t\t\tdiv.appendChild(full_button)\t\t\tdialogHeader.appendChild(div)\t\t\t\t\t\tlet full = false\t\t\t/**\t\t\t* 双击全屏\t\t\t*/\t\t\tdialogHeader.addEventListener('dblclick',full_dia)\t\t\tfunction full_dia(){\t\t\t\tif (full) {\t\t\t\t\tdomset = {\t\t\t\t\t\tx: clientWidth / 4,\t\t\t\t\t\ty: clientHeight * 15 / 100\t\t\t\t\t}\t\t\t\t\tdomDrag.style.width = \"50%\"\t\t\t\t\tdomDrag.style.height = \"auto\"\t\t\t\t\tdomDrag.style.marginLeft = domset.x + 'px'\t\t\t\t\tdomDrag.style.marginTop = domset.y + 'px'\t\t\t\t\tfull_button.innerHTML='&lt;i class=\"iconfont icon-full\"&gt;&lt;/i&gt;'\t\t\t\t\t// 由于我弹窗里面有 echarts 图表，要让图表修改大小，使用的是vue3 bus\t\t\t\t\tbus.bus.off('domResize')\t\t\t\t\tbus.bus.emit('domResize', {\t\t\t\t\t\twidth: domDrag.clientWidth,\t\t\t\t\t\theight: domDrag.clientHeight\t\t\t\t\t})\t\t\t\t\tfull = false\t\t\t\t} else {\t\t\t\t\tdomDrag.style.width = \"100%\"\t\t\t\t\tdomDrag.style.height = \"100%\"\t\t\t\t\tdomDrag.style.marginLeft = '0'\t\t\t\t\tdomDrag.style.marginTop = '0'\t\t\t\t\tfull_button.innerHTML='&lt;i class=\"iconfont icon-fullscreen-exit\"&gt;&lt;/i&gt;'\t\t\t\t\tbus.bus.off('domResize')\t\t\t\t\tbus.bus.emit('domResize', {\t\t\t\t\t\twidth: domDrag.clientWidth,\t\t\t\t\t\theight: domDrag.clientHeight\t\t\t\t\t})\t\t\t\t\tfull = true\t\t\t\t}\t\t\t}\t\t\t/**\t\t\t* 鼠标按下，开始拖拽，添加 mousemove、mouseup 事件\t\t\t*/\t\t\tdialogHeader.onmousedown = (e) =&gt; {\t\t\t\t// 判断对话框是否重新打开\t\t\t\tif (domDrag.style.marginTop === '15vh') {\t\t\t\t\t// 重新打开，设置 domset.y  top\t\t\t\t\tdomset.y = clientHeight * 15 / 100\t\t\t\t}\t\t\t\tstart.x = e.clientX\t\t\t\tstart.y = e.clientY\t\t\t\tdomDrag.style.cursor = 'move' // 改变光标形状\t\t\t\t// 鼠标拖出浏览器外部的时候会选中文本，需要禁用\t\t\t\tdocument.body.style.userSelect = 'none'\t\t\t\t// 使用 document 的 mousemove ，这样鼠标脱离 header 区域还是可以正常拖动（贴着窗口边缘移动）\t\t\t\t// 鼠标移动，实时跟踪\t\t\t\tdocument.addEventListener('mousemove', dia_mousemove)\t\t\t\t// 鼠标抬起，结束拖拽，once: 只执行一次\t\t\t\tdocument.addEventListener('mouseup', dia_mouseup, {\t\t\t\t\tonce: true\t\t\t\t})\t\t\t}\t\t\t/**\t\t\t* 鼠标移动，实时跟踪\t\t\t*/\t\t\tfunction dia_mousemove(e) {\t\t\t\tif (start.x === 0) { // 不是拖拽状态\t\t\t\t\treturn\t\t\t\t}\t\t\t\tmove.x = e.clientX - start.x\t\t\t\tmove.y = e.clientY - start.y\t\t\t\t// 弹窗 左、上、右、下 到窗口边缘的距离\t\t\t\tlet left = domset.x + move.x,\t\t\t\t\ttop = domset.y + move.y\t\t\t\tlet right = left + domDrag.clientWidth,\t\t\t\t\tbottom = top + domDrag.clientHeight\t\t\t\t\t\t\t\t\tif (left &lt;= 0) {\t\t\t\t\tdomDrag.style.marginLeft = '0px'\t\t\t\t} else if (right &gt;= clientWidth) {\t\t\t\t\tdomDrag.style.marginLeft = (clientWidth - domDrag.clientWidth) + 'px'\t\t\t\t} else {\t\t\t\t\tdomDrag.style.marginLeft = left + 'px'\t\t\t\t}\t\t\t\tif (top &lt;= 0) {\t\t\t\t\tdomDrag.style.marginTop = '0px'\t\t\t\t} else if (bottom &gt;= clientHeight) {\t\t\t\t\tdomDrag.style.marginTop = (clientHeight - domDrag.clientHeight) + 'px'\t\t\t\t} else {\t\t\t\t\tdomDrag.style.marginTop = top + 'px'\t\t\t\t}\t\t\t}\t\t\t/**\t\t\t* 鼠标抬起，结束拖拽，移除 mousemove 事件\t\t\t*/\t\t\tfunction dia_mouseup(e) {\t\t\t\tmove.x = e.clientX - start.x\t\t\t\tmove.y = e.clientY - start.y\t\t\t\tlet left = domset.x + move.x,\t\t\t\t\ttop = domset.y + move.y\t\t\t\tlet right = left + domDrag.clientWidth,\t\t\t\t\tbottom = top + domDrag.clientHeight\t\t\t\t\t\t\t\t\tdomDrag.style.cursor = '' // 恢复光标形状\t\t\t\tdocument.body.style.userSelect = 'text' // 恢复body可选中\t\t\t\t// 结束拖拽\t\t\t\tstart.x = 0\t\t\t\tif (left &lt;= 0) {\t\t\t\t\tdomDrag.style.marginLeft = '0px'\t\t\t\t\tdomset.x = 0\t\t\t\t} else if (right &gt;= clientWidth) {\t\t\t\t\tdomDrag.style.marginLeft = (clientWidth - domDrag.clientWidth) + 'px'\t\t\t\t\tdomset.x = clientWidth - domDrag.clientWidth\t\t\t\t} else {\t\t\t\t\tdomDrag.style.marginLeft = left + 'px'\t\t\t\t\tdomset.x = left\t\t\t\t}\t\t\t\tif (top &lt;= 0) {\t\t\t\t\tdomDrag.style.marginTop = '0px'\t\t\t\t\tdomset.y = 0\t\t\t\t} else if (bottom &gt;= clientHeight) {\t\t\t\t\tdomDrag.style.marginTop = (clientHeight - domDrag.clientHeight) + 'px'\t\t\t\t\tdomset.y = clientHeight - domDrag.clientHeight\t\t\t\t} else {\t\t\t\t\tdomDrag.style.marginTop = top + 'px'\t\t\t\t\tdomset.y = top\t\t\t\t}\t\t\t\t// 结束拖拽\t\t\t\tdocument.removeEventListener('mousemove', dia_mousemove)\t\t\t}\t\t}\t})}export default dialogDrag","categories":["vue","element-plus"],"tags":["vue","element-plus","el-dialog","弹窗","拖拽","全屏"]}]